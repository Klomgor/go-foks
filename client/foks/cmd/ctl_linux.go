// Copyright (c) 2025 ne43, Inc.
// Licensed under the MIT License. See LICENSE in the project root for details.

//go:build linux

package cmd

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/coreos/go-systemd/v22/dbus"
	"github.com/foks-proj/go-foks/client/libclient"
	"github.com/foks-proj/go-foks/lib/core"
	"github.com/spf13/cobra"
)

type unit struct {
	dat string
	exe string
}

func (u *unit) name() string {
	return "foks.service"
}

func (u *unit) getExe() (string, error) {
	if u.exe != "" {
		return u.exe, nil

	}
	exe, err := os.Executable()
	if err != nil {
		return "", err
	}
	u.exe = exe
	return exe, nil
}

func (u *unit) create() error {
	exe, err := u.getExe()
	if err != nil {
		return err
	}
	tmplS := `# Autogenerated by {{.Bin}}; if you make custom modifications, delete this line to prevent overwrite.
[Unit]
Description=Foks background agent


[Service]
ExecStart={{.Bin}} agent
RestartSec=50ms
Restart=always

# Delays for 5s is SERVICE_RESULT != success
ExecStopPost={{.Bin}} ctl delay 5s

[Install]
WantedBy=default.target
`
	tmpl, err := template.New("unit").Parse(tmplS)
	if err != nil {
		return err
	}
	data := struct {
		Bin string
	}{
		Bin: exe,
	}
	buf := new(bytes.Buffer)
	err = tmpl.Execute(buf, data)
	if err != nil {
		return err
	}
	ret := buf.String()
	u.dat = ret
	return nil
}

func (u *unit) path(m libclient.MetaContext) (core.Path, error) {
	foksConfig, err := m.G().Cfg().HomeFinder().ConfigDir()
	if err != nil {
		return "", err
	}
	config := filepath.Dir(foksConfig)
	unitPath := core.Path(filepath.Join(config, "systemd", "user", u.name()))
	return unitPath, nil
}

func (u *unit) write(
	m libclient.MetaContext,
) error {
	unitPath, err := u.path(m)
	if err != nil {
		return err
	}
	err = u.create()
	if err != nil {
		return err
	}
	err = unitPath.MakeParentDirs()
	if err != nil {
		return err
	}
	err = unitPath.WriteFile([]byte(u.dat), 0644)
	if err != nil {
		return err
	}
	return nil
}

func (u *unit) autowriteExists(
	m libclient.MetaContext,
) (bool, error) {
	path, err := u.path(m)
	if err != nil {
		return false, err
	}
	_, err = path.Stat()
	if err != nil {
		return false, nil
	}
	dat, err := path.ReadFile()
	if err != nil {
		return false, err
	}
	return strings.HasPrefix(string(dat), "# Autogenerated by"), nil
}

func (u *unit) writeUnlessModified(
	m libclient.MetaContext,
) error {
	exists, err := u.autowriteExists(m)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}
	return u.write(m)
}

func (u *unit) unlink(
	m libclient.MetaContext,
) error {
	ok, err := u.autowriteExists(m)
	if err != nil {
		return err
	}
	if !ok {
		return nil
	}
	path, err := u.path(m)
	if err != nil {
		return err
	}
	return path.Remove()
}

func (u *unit) start(
	m libclient.MetaContext,
) error {
	err := u.writeUnlessModified(m)
	if err != nil {
		return err
	}
	conn, err := dbus.NewUserConnectionContext(m.Ctx())
	if err != nil {
		return err
	}
	defer conn.Close()

	// 1. Reload the user daemon (equivalent to: systemctl --user daemon-reload)
	err = conn.ReloadContext(m.Ctx())
	if err != nil {
		return err
	}

	// 2. Enable the service (equivalent to: systemctl --user enable my-agent.service)
	// The second argument 'false' indicates whether to force the change.
	// The third argument 'true' indicates runtime enabling (i.e. no persistent change).
	_, _, err = conn.EnableUnitFilesContext(m.Ctx(), []string{u.name()}, false, true)
	if err != nil {
		return err
	}

	// 3. Start the service (equivalent to: systemctl --user start my-agent.service)
	// The "replace" mode means any existing job for the unit will be replaced.
	jobChan := make(chan string, 1)
	_, err = conn.StartUnitContext(m.Ctx(), u.name(), "replace", jobChan)
	if err != nil {
		return err
	}

	// wait for the job to complete.
	jobResult := <-jobChan

	prnt := m.G().UIs().Terminal.Printf

	prnt("foks agent launched via systemd with result: %s\n", jobResult)
	return nil
}

func (u *unit) stop(
	m libclient.MetaContext,
) error {
	conn, err := dbus.NewUserConnectionContext(m.Ctx())
	if err != nil {
		return err
	}
	defer conn.Close()

	// 1. stop the process
	jobChan := make(chan string, 1)
	_, err = conn.StopUnitContext(m.Ctx(), u.name(), "replace", jobChan)
	if err != nil {
		return err
	}
	jobResult := <-jobChan
	prnt := m.G().UIs().Terminal.Printf
	prnt("foks agent stopped with result: %s\n", jobResult)

	// 2. disable the service
	_, err = conn.DisableUnitFilesContext(m.Ctx(), []string{u.name()}, false)
	if err != nil {
		return err
	}

	// 3. unlink the service
	err = u.unlink(m)
	if err != nil {
		return err
	}

	return nil
}

type status struct {
	activeState string
	subState    string
}

func (u *unit) status(
	m libclient.MetaContext,
) (
	*status,
	error,
) {
	conn, err := dbus.NewUserConnectionContext(m.Ctx())
	if err != nil {
		return nil, err
	}
	defer conn.Close()

	// 1. get the status of the service
	unitStatus, err := conn.GetUnitPropertiesContext(m.Ctx(), u.name())
	if err != nil {
		return nil, err
	}
	activeState, ok := unitStatus["ActiveState"].(string)
	ret := &status{}
	if ok {
		ret.activeState = activeState
	}
	subState, ok := unitStatus["SubState"].(string)
	if ok {
		ret.subState = subState
	}
	return ret, nil
}

func RunCtlStart(m libclient.MetaContext, cmd *cobra.Command, arg []string) error {
	err := setupCtlCmd(m)
	if err != nil {
		return err
	}
	u := &unit{}
	err = u.start(m)
	if err != nil {
		return err
	}
	prnt := m.G().UIs().Terminal.Printf
	prnt("foks agent launched via systemd; it will start automatically on login\n")
	prnt("Use `foks ctl stop` to stop and uninstall it\n")
	return nil
}

func RunCtlStop(m libclient.MetaContext, cmd *cobra.Command, arg []string) error {
	err := setupCtlCmd(m)
	if err != nil {
		return err
	}
	u := &unit{}
	err = u.stop(m)
	if err != nil {
		return err
	}
	return nil
}

func RunCtlStatus(m libclient.MetaContext, cmd *cobra.Command, arg []string) error {
	err := setupCtlCmd(m)
	if err != nil {
		return err
	}
	u := &unit{}
	st, err := u.status(m)
	if err != nil {
		return err
	}
	prnt := m.G().UIs().Terminal.Printf
	prnt("foks agent is in state: %s %s\n", st.activeState, st.subState)
	return nil
}

func RunCtlRestart(m libclient.MetaContext, cmd *cobra.Command, arg []string) error {
	return RunCtlShutdown(m, cmd, arg)
}

func doDaemonize(m libclient.MetaContext) error {
	return core.NotImplementedError{}
}

func runCtlDelay(m libclient.MetaContext, cmd *cobra.Command, arg []string) error {
	if os.Getenv("SERVICE_RESULT") == "success" {
		return nil
	}

	if len(arg) != 1 {
		return core.BadArgsError("delay requires one argument -- the interval to delay")
	}
	dur, err := time.ParseDuration(arg[0])
	if err != nil {
		return err
	}

	m.Infow("ctl delay", "duration", dur, "stage", "start")
	time.Sleep(dur)
	m.Infow("ctl delay", "duration", dur, "stage", "end")

	return nil
}

func AddPlatformCtlCommands(m libclient.MetaContext, cmd *cobra.Command) {
	delay := &cobra.Command{
		Use:   "delay",
		Short: "delay based on SERVICE_RESULT environment variable (for systemd)",
		Long:  "delay the agent start by a given number of seconds if SERVER_RESULT != 'success'",
		RunE: func(cmd *cobra.Command, args []string) error {
			return runCtlDelay(m, cmd, args)
		},
	}
	cmd.AddCommand(delay)
}
